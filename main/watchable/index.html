<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Allows watching for value changes in both multi-threaded and asynchronous contexts."><meta name="keywords" content="rust, rustlang, rust-lang, watchable"><title>watchable - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../watchable/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Crate watchable</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all watchable's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><div id="sidebar-vars" data-name="watchable" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../watchable/index.html"><img class="rust-logo" src="../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">watchable</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/watchable/lib.rs.html#1-537" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Allows watching for value changes in both multi-threaded and asynchronous
contexts.</p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="watchable forbids unsafe code" />
<a href="https://crates.io/crates/watchable"><img src="https://img.shields.io/crates/v/watchable.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/watchable/actions?query=workflow:Tests"><img src="https://img.shields.io/github/workflow/status/khonsulabs/watchable/Tests/main" alt="Live Build Status" /></a>
<a href="https://watchable.bonsaidb.io/coverage/"><img src="https://khonsulabs.github.io/watchable/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://watchable.bonsaidb.io/main/watchable/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p><code>watchable</code> is a Multi-Producer, Multi-Consumer channel where each consumer
is only guaranteed to receive the most recently written value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">watchable</span>::{<span class="ident">Watchable</span>, <span class="ident">Watcher</span>};

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create the watchable container for our u32s.</span>
    <span class="kw">let</span> <span class="ident">watchable</span> <span class="op">=</span> <span class="ident">Watchable::new</span>(<span class="number">0</span>);
    <span class="comment">// Create a subscriber that watches for changes to the stored value.</span>
    <span class="kw">let</span> <span class="ident">watcher</span> <span class="op">=</span> <span class="ident">watchable</span>.<span class="ident">subscribe</span>();
    <span class="comment">// Spawn a background worker that will print out the values it reads.</span>
    <span class="kw">let</span> <span class="ident">watching_thread</span> <span class="op">=</span> <span class="ident">std::thread::spawn</span>(<span class="op">|</span><span class="op">|</span> <span class="ident">watching_thread</span>(<span class="ident">watcher</span>));

    <span class="comment">// Send a sequence of numbers, ending at 1,000.</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1</span>..<span class="op">=</span><span class="number">1000</span> {
        <span class="ident">watchable</span>.<span class="ident">replace</span>(<span class="ident">i</span>);
    }

    <span class="comment">// Wait for the thread to exit.</span>
    <span class="ident">watching_thread</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
}

<span class="kw">fn</span> <span class="ident">watching_thread</span>(<span class="ident">watcher</span>: <span class="ident">Watcher</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) {
    <span class="comment">// A Watcher can be used as an iterator which always produces the most</span>
    <span class="comment">// recent value, or parks the current thread until a new value is available.</span>
    <span class="kw">for</span> <span class="ident">value</span> <span class="kw">in</span> <span class="ident">watcher</span> {
        <span class="comment">// The value we received will not necessarily be sequential, even though</span>
        <span class="comment">// the main thread is publishing a complete sequence.</span>
        <span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
        <span class="kw">if</span> <span class="ident">value</span> <span class="op">==</span> <span class="number">1000</span> {
            <span class="kw">break</span>;
        }
    }
}</code></pre></div>
<p>When running this example, the output will look similar to:</p>
<div class="example-wrap"><pre class="language-sh"><code>...
Read value: 876
Read value: 897
Read value: 923
Read value: 944
Read value: 957
Read value: 977
Read value: 995
Read value: 1000</code></pre></div>
<p>As you can see, the receiving thread doesn’t receive every value. Each watcher
is guaranteed to be notified when changes occur and is guaranteed to be able to
retrieve the most recent value.</p>
<h3 id="async-support" class="section-header"><a href="#async-support">Async Support</a></h3>
<p>The <code>Watcher</code> type can be used in async code in multiple ways:</p>
<ul>
<li><code>Watcher::into_stream()</code>: Wraps the watcher in a type that implements
<code>futures::Stream</code>.</li>
<li><code>Watcher::wait_async().await</code>: Pauses execution of the current task until a
new value is available to be read. <code>Watcher::read()</code> can be used to retrieve
the current value after <code>wait_async()</code> has returned.</li>
</ul>
<p>Here is the same example as above, except this time using <code>Watcher::into_stream</code> with Tokio:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">futures_util::StreamExt</span>;
<span class="kw">use</span> <span class="ident">watchable</span>::{<span class="ident">Watchable</span>, <span class="ident">Watcher</span>};

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create the watchable container for our u32s.</span>
    <span class="kw">let</span> <span class="ident">watchable</span> <span class="op">=</span> <span class="ident">Watchable::new</span>(<span class="number">0</span>);
    <span class="comment">// Create a subscriber that watches for changes to the stored value.</span>
    <span class="kw">let</span> <span class="ident">watcher</span> <span class="op">=</span> <span class="ident">watchable</span>.<span class="ident">subscribe</span>();
    <span class="comment">// Spawn a background worker that will print out the values it reads.</span>
    <span class="kw">let</span> <span class="ident">watching_task</span> <span class="op">=</span> <span class="ident">tokio::task::spawn</span>(<span class="ident">watching_task</span>(<span class="ident">watcher</span>));

    <span class="comment">// Send a sequence of numbers, ending at 1,000.</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1</span>..<span class="op">=</span><span class="number">1000</span> {
        <span class="ident">watchable</span>.<span class="ident">replace</span>(<span class="ident">i</span>);
    }

    <span class="comment">// Wait for the thread to exit.</span>
    <span class="ident">watching_task</span>.<span class="kw">await</span>.<span class="ident">unwrap</span>();
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">watching_task</span>(<span class="ident">watcher</span>: <span class="ident">Watcher</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) {
    <span class="comment">// A Watcher can be converted into a Stream, which allows for asynchronous</span>
    <span class="comment">// iteration.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">watcher</span>.<span class="ident">into_stream</span>();
    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">value</span>) <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">next</span>().<span class="kw">await</span> {
        <span class="comment">// The value we received will not necessarily be sequential, even though</span>
        <span class="comment">// the main thread is publishing a complete sequence.</span>
        <span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
        <span class="kw">if</span> <span class="ident">value</span> <span class="op">==</span> <span class="number">1000</span> {
            <span class="kw">break</span>;
        }
    }
}</code></pre></div>
<p><code>watchable</code> is compatible with all async runtimes.</p>
<h3 id="open-source-licenses" class="section-header"><a href="#open-source-licenses">Open-source Licenses</a></h3>
<p>This project, like all projects from <a href="https://khonsulabs.com/">Khonsu Labs</a>, are
open-source. This repository is available under the <a href="./LICENSE-MIT">MIT License</a>
or the <a href="./LICENSE-APACHE">Apache License 2.0</a>.</p>
<p>To learn more about contributing, please see <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watchable.html" title="watchable::Watchable struct">Watchable</a></div><div class="item-right docblock-short"><p>A watchable wrapper for a value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableReadGuard.html" title="watchable::WatchableReadGuard struct">WatchableReadGuard</a></div><div class="item-right docblock-short"><p>A read guard that allows reading the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>. No values can be stored within the source <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> while
this guard exists.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableWriteGuard.html" title="watchable::WatchableWriteGuard struct">WatchableWriteGuard</a></div><div class="item-right docblock-short"><p>A write guard that allows updating the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watcher.html" title="watchable::Watcher struct">Watcher</a></div><div class="item-right docblock-short"><p>An observer of a <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatcherStream.html" title="watchable::WatcherStream struct">WatcherStream</a></div><div class="item-right docblock-short"><p>Asynchronous iterator for a <a href="struct.Watcher.html" title="Watcher"><code>Watcher</code></a>. Implements [<code>Stream</code>].</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="watchable" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>