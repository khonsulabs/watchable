<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Enables watching for value changes in both multi-threaded and asynchronous contexts. Similar to tokio::sync::watch, but able to work in non-async codebases."><meta name="keywords" content="rust, rustlang, rust-lang, watchable"><title>watchable - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../watchable/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../watchable/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate watchable</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../watchable/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">watchable</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/watchable/lib.rs.html#1-860">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Enables watching for value changes in both multi-threaded and asynchronous
contexts. Similar to <a href="https://docs.rs/tokio/latest/tokio/sync/watch/index.html">tokio::sync::watch</a>, but able to work in non-async codebases.</p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="watchable forbids unsafe code" />
<a href="https://crates.io/crates/watchable"><img src="https://img.shields.io/crates/v/watchable.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/watchable/actions?query=workflow:Tests"><img src="https://img.shields.io/github/workflow/status/khonsulabs/watchable/Tests/main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/watchable/coverage/"><img src="https://khonsulabs.github.io/watchable/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://khonsulabs.github.io/watchable/main/watchable/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p><code>watchable</code> is a Multi-Producer, Multi-Consumer channel where each consumer
is only guaranteed to receive the most recently written value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">watchable</span>::{<span class="ident">Watchable</span>, <span class="ident">Watcher</span>};

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the</span>
    <span class="comment">// contained value changes.</span>
    <span class="kw">let</span> <span class="ident">watchable</span> <span class="op">=</span> <span class="ident">Watchable::default</span>();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the</span>
    <span class="comment">// contained value as it is updated.</span>
    <span class="kw">let</span> <span class="ident">watcher</span> <span class="op">=</span> <span class="ident">watchable</span>.<span class="ident">watch</span>();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.</span>
    <span class="kw">let</span> <span class="ident">watching_thread</span> <span class="op">=</span> <span class="ident">std::thread::spawn</span>(<span class="op">|</span><span class="op">|</span> <span class="ident">watching_thread</span>(<span class="ident">watcher</span>));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting</span>
    <span class="comment">// watchers will be notified there is a new value available.</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1_u32</span>..<span class="op">=</span><span class="number">1000</span> {
        <span class="ident">watchable</span>.<span class="ident">replace</span>(<span class="ident">i</span>);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure</span>
    <span class="comment">// watchers are notified of the disconnection. Watchers are guaranteed to be</span>
    <span class="comment">// able to read the final value.</span>
    <span class="ident">drop</span>(<span class="ident">watchable</span>);

    <span class="comment">// Wait for the thread to exit.</span>
    <span class="ident">watching_thread</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
}

<span class="kw">fn</span> <span class="ident">watching_thread</span>(<span class="ident">watcher</span>: <span class="ident">Watcher</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) {
    <span class="comment">// A Watcher can be used as an iterator which always reads the most</span>
    <span class="comment">// recent value, or parks the current thread until a new value is available.</span>
    <span class="kw">for</span> <span class="ident">value</span> <span class="kw">in</span> <span class="ident">watcher</span> {
        <span class="comment">// The value we read will not necessarily be sequential, even though the</span>
        <span class="comment">// main thread is storing a complete sequence.</span>
        <span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p>When running this example, the output will look similar to:</p>
<div class="example-wrap"><pre class="language-sh"><code>...
Read value: 876
Read value: 897
Read value: 923
Read value: 944
Read value: 957
Read value: 977
Read value: 995
Read value: 1000</code></pre></div>
<p>As you can see, the receiving thread doesn’t receive every value. Each watcher
is guaranteed to be notified when changes occur and is guaranteed to be able to
retrieve the most recent value.</p>
<h3 id="async-support"><a href="#async-support">Async Support</a></h3>
<p>The <code>Watcher</code> type can be used in async code in multiple ways:</p>
<ul>
<li><code>Watcher::into_stream()</code>: Wraps the watcher in a type that implements
<code>futures::Stream</code>.</li>
<li><code>Watcher::wait_async().await</code>: Pauses execution of the current task until a
new value is available to be read. <code>Watcher::read()</code> can be used to retrieve
the current value after <code>wait_async()</code> has returned.</li>
</ul>
<p>Here is the same example as above, except this time using <code>Watcher::into_stream</code> with Tokio:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">futures_util::StreamExt</span>;
<span class="kw">use</span> <span class="ident">watchable</span>::{<span class="ident">Watchable</span>, <span class="ident">Watcher</span>};

<span class="attribute">#[<span class="ident">tokio::main</span>]</span>
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the</span>
    <span class="comment">// contained value changes.</span>
    <span class="kw">let</span> <span class="ident">watchable</span> <span class="op">=</span> <span class="ident">Watchable::default</span>();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the</span>
    <span class="comment">// contained value as it is updated.</span>
    <span class="kw">let</span> <span class="ident">watcher</span> <span class="op">=</span> <span class="ident">watchable</span>.<span class="ident">watch</span>();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.</span>
    <span class="kw">let</span> <span class="ident">watching_task</span> <span class="op">=</span> <span class="ident">tokio::task::spawn</span>(<span class="ident">watching_task</span>(<span class="ident">watcher</span>));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting</span>
    <span class="comment">// watchers will be notified there is a new value available.</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1_u32</span>..<span class="op">=</span><span class="number">1000</span> {
        <span class="ident">watchable</span>.<span class="ident">replace</span>(<span class="ident">i</span>);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure</span>
    <span class="comment">// watchers are notified of the disconnection. Watchers are guaranteed to be</span>
    <span class="comment">// able to read the final value.</span>
    <span class="ident">drop</span>(<span class="ident">watchable</span>);

    <span class="comment">// Wait for the spawned task to exit.</span>
    <span class="ident">watching_task</span>.<span class="kw">await</span>.<span class="ident">unwrap</span>();
}

<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">watching_task</span>(<span class="ident">watcher</span>: <span class="ident">Watcher</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) {
    <span class="comment">// A Watcher can be converted into a Stream, which allows for asynchronous</span>
    <span class="comment">// iteration.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">watcher</span>.<span class="ident">into_stream</span>();
    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">value</span>) <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">next</span>().<span class="kw">await</span> {
        <span class="comment">// The value we received will not necessarily be sequential, even though</span>
        <span class="comment">// the main thread is publishing a complete sequence.</span>
        <span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p><code>watchable</code> is compatible with all async runtimes.</p>
<h3 id="open-source-licenses"><a href="#open-source-licenses">Open-source Licenses</a></h3>
<p>This project, like all projects from <a href="https://khonsulabs.com/">Khonsu Labs</a>, are
open-source. This repository is available under the <a href="./LICENSE-MIT">MIT License</a>
or the <a href="./LICENSE-APACHE">Apache License 2.0</a>.</p>
<p>To learn more about contributing, please see <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Disconnected.html" title="watchable::Disconnected struct">Disconnected</a></div><div class="item-right docblock-short"><p>A watch operation failed because all <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> instances have been
dropped.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watchable.html" title="watchable::Watchable struct">Watchable</a></div><div class="item-right docblock-short"><p>A watchable wrapper for a value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableReadGuard.html" title="watchable::WatchableReadGuard struct">WatchableReadGuard</a></div><div class="item-right docblock-short"><p>A read guard that allows reading the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>. No values can be stored within the source <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> while
this guard exists.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableWriteGuard.html" title="watchable::WatchableWriteGuard struct">WatchableWriteGuard</a></div><div class="item-right docblock-short"><p>A write guard that allows updating the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watcher.html" title="watchable::Watcher struct">Watcher</a></div><div class="item-right docblock-short"><p>An observer of a <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatcherStream.html" title="watchable::WatcherStream struct">WatcherStream</a></div><div class="item-right docblock-short"><p>Asynchronous iterator for a <a href="struct.Watcher.html" title="Watcher"><code>Watcher</code></a>. Implements [<code>Stream</code>].</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TimeoutError.html" title="watchable::TimeoutError enum">TimeoutError</a></div><div class="item-right docblock-short"><p>A watch operation with a timeout failed.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="watchable" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>