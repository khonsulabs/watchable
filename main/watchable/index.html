<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`watchable` implements an observable RwLock-like type that is compatible with both multi-threaded and async code. Inspired by tokio::sync::watch."><title>watchable - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="watchable" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../watchable/index.html">watchable</a><span class="version">1.1.2</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">watchable</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/watchable/lib.rs.html#1-911">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>watchable</code> implements an observable RwLock-like type that is compatible with
both multi-threaded and async code. Inspired by
<a href="https://docs.rs/tokio/latest/tokio/sync/watch/index.html">tokio::sync::watch</a>.</p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="watchable forbids unsafe code" />
<a href="https://crates.io/crates/watchable"><img src="https://img.shields.io/crates/v/watchable.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/watchable/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/watchable/tests.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/watchable/coverage/"><img src="https://khonsulabs.github.io/watchable/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://khonsulabs.github.io/watchable/main/watchable/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p><code>watchable</code> is an RwLock-like type that allows watching for value changes
using a Multi-Producer, Multi-Consumer approach where each consumer is only
guaranteed to receive the most recently written value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>watchable::{Watchable, Watcher};

<span class="kw">fn </span>main() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the
    // contained value changes.
    </span><span class="kw">let </span>watchable = Watchable::default();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the
    // contained value as it is updated.
    </span><span class="kw">let </span>watcher = watchable.watch();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.
    </span><span class="kw">let </span>watching_thread = std::thread::spawn(|| watching_thread(watcher));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting
    // watchers will be notified there is a new value available.
    </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">1_u32</span>..=<span class="number">1000 </span>{
        watchable.replace(i);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure
    // watchers are notified of the disconnection. Watchers are guaranteed to be
    // able to read the final value.
    </span>drop(watchable);

    <span class="comment">// Wait for the thread to exit.
    </span>watching_thread.join().unwrap();
}

<span class="kw">fn </span>watching_thread(watcher: Watcher&lt;u32&gt;) {
    <span class="comment">// A Watcher can be used as an iterator which always reads the most
    // recent value, or parks the current thread until a new value is available.
    </span><span class="kw">for </span>value <span class="kw">in </span>watcher {
        <span class="comment">// The value we read will not necessarily be sequential, even though the
        // main thread is storing a complete sequence.
        </span><span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p>When running this example, the output will look similar to:</p>
<div class="example-wrap"><pre class="language-sh"><code>...
Read value: 876
Read value: 897
Read value: 923
Read value: 944
Read value: 957
Read value: 977
Read value: 995
Read value: 1000
</code></pre></div>
<p>As you can see, the receiving thread doesn’t receive every value. Each watcher
is guaranteed to be notified when changes occur and is guaranteed to be able to
retrieve the most recent value.</p>
<h3 id="async-support"><a href="#async-support">Async Support</a></h3>
<p>The <code>Watcher</code> type can be used in async code in multiple ways:</p>
<ul>
<li><code>Watcher::into_stream()</code>: Wraps the watcher in a type that implements
<code>futures::Stream</code>.</li>
<li><code>Watcher::wait_async().await</code>: Pauses execution of the current task until a
new value is available to be read. <code>Watcher::read()</code> can be used to retrieve
the current value after <code>wait_async()</code> has returned.</li>
</ul>
<p>Here is the same example as above, except this time using <code>Watcher::into_stream</code> with Tokio:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_util::StreamExt;
<span class="kw">use </span>watchable::{Watchable, Watcher};

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the
    // contained value changes.
    </span><span class="kw">let </span>watchable = Watchable::default();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the
    // contained value as it is updated.
    </span><span class="kw">let </span>watcher = watchable.watch();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.
    </span><span class="kw">let </span>watching_task = tokio::task::spawn(watching_task(watcher));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting
    // watchers will be notified there is a new value available.
    </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">1_u32</span>..=<span class="number">1000 </span>{
        watchable.replace(i);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure
    // watchers are notified of the disconnection. Watchers are guaranteed to be
    // able to read the final value.
    </span>drop(watchable);

    <span class="comment">// Wait for the spawned task to exit.
    </span>watching_task.<span class="kw">await</span>.unwrap();
}

<span class="kw">async fn </span>watching_task(watcher: Watcher&lt;u32&gt;) {
    <span class="comment">// A Watcher can be converted into a Stream, which allows for asynchronous
    // iteration.
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = watcher.into_stream();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(value) = stream.next().<span class="kw">await </span>{
        <span class="comment">// The value we received will not necessarily be sequential, even though
        // the main thread is publishing a complete sequence.
        </span><span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p><code>watchable</code> is compatible with all async runtimes.</p>
<h3 id="open-source-licenses"><a href="#open-source-licenses">Open-source Licenses</a></h3>
<p>This project, like all projects from <a href="https://khonsulabs.com/">Khonsu Labs</a>, are
open-source. This repository is available under the <a href="./LICENSE-MIT">MIT License</a>
or the <a href="./LICENSE-APACHE">Apache License 2.0</a>.</p>
<p>To learn more about contributing, please see <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Disconnected.html" title="struct watchable::Disconnected">Disconnected</a></div><div class="desc docblock-short">A watch operation failed because all <a href="struct.Watchable.html" title="struct watchable::Watchable"><code>Watchable</code></a> instances have been
dropped.</div></li><li><div class="item-name"><a class="struct" href="struct.Watchable.html" title="struct watchable::Watchable">Watchable</a></div><div class="desc docblock-short">A watchable wrapper for a value.</div></li><li><div class="item-name"><a class="struct" href="struct.WatchableReadGuard.html" title="struct watchable::WatchableReadGuard">WatchableReadGuard</a></div><div class="desc docblock-short">A read guard that allows reading the currently stored value in a
<a href="struct.Watchable.html" title="struct watchable::Watchable"><code>Watchable</code></a>. No values can be stored within the source <a href="struct.Watchable.html" title="struct watchable::Watchable"><code>Watchable</code></a> while
this guard exists.</div></li><li><div class="item-name"><a class="struct" href="struct.WatchableWriteGuard.html" title="struct watchable::WatchableWriteGuard">WatchableWriteGuard</a></div><div class="desc docblock-short">A write guard that allows updating the currently stored value in a
<a href="struct.Watchable.html" title="struct watchable::Watchable"><code>Watchable</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Watcher.html" title="struct watchable::Watcher">Watcher</a></div><div class="desc docblock-short">An observer of a <a href="struct.Watchable.html" title="struct watchable::Watchable"><code>Watchable</code></a> value.</div></li><li><div class="item-name"><a class="struct" href="struct.WatcherStream.html" title="struct watchable::WatcherStream">WatcherStream</a></div><div class="desc docblock-short">Asynchronous iterator for a <a href="struct.Watcher.html" title="struct watchable::Watcher"><code>Watcher</code></a>. Implements [<code>Stream</code>].</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.TimeoutError.html" title="enum watchable::TimeoutError">TimeoutError</a></div><div class="desc docblock-short">A watch operation with a timeout failed.</div></li></ul></section></div></main></body></html>