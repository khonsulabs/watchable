<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`watchable` implements an observable RwLock-like type that is compatible with both multi-threaded and async code. Inspired by tokio::sync::watch."><meta name="keywords" content="rust, rustlang, rust-lang, watchable"><title>watchable - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../watchable/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../watchable/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate watchable</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.1.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">watchable</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/watchable/lib.rs.html#1-889">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>watchable</code> implements an observable RwLock-like type that is compatible with
both multi-threaded and async code. Inspired by
<a href="https://docs.rs/tokio/latest/tokio/sync/watch/index.html">tokio::sync::watch</a>.</p>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="watchable forbids unsafe code" />
<a href="https://crates.io/crates/watchable"><img src="https://img.shields.io/crates/v/watchable.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/watchable/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/watchable/tests.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/watchable/coverage/"><img src="https://khonsulabs.github.io/watchable/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://khonsulabs.github.io/watchable/main/watchable/"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation for main branch" /></a></p>
<p><code>watchable</code> is an RwLock-like type that allows watching for value changes
using a Multi-Producer, Multi-Consumer approach where each consumer is only
guaranteed to receive the most recently written value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>watchable::{Watchable, Watcher};

<span class="kw">fn </span>main() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the
    // contained value changes.
    </span><span class="kw">let </span>watchable = Watchable::default();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the
    // contained value as it is updated.
    </span><span class="kw">let </span>watcher = watchable.watch();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.
    </span><span class="kw">let </span>watching_thread = std::thread::spawn(|| watching_thread(watcher));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting
    // watchers will be notified there is a new value available.
    </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">1_u32</span>..=<span class="number">1000 </span>{
        watchable.replace(i);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure
    // watchers are notified of the disconnection. Watchers are guaranteed to be
    // able to read the final value.
    </span>drop(watchable);

    <span class="comment">// Wait for the thread to exit.
    </span>watching_thread.join().unwrap();
}

<span class="kw">fn </span>watching_thread(watcher: Watcher&lt;u32&gt;) {
    <span class="comment">// A Watcher can be used as an iterator which always reads the most
    // recent value, or parks the current thread until a new value is available.
    </span><span class="kw">for </span>value <span class="kw">in </span>watcher {
        <span class="comment">// The value we read will not necessarily be sequential, even though the
        // main thread is storing a complete sequence.
        </span><span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p>When running this example, the output will look similar to:</p>
<div class="example-wrap"><pre class="language-sh"><code>...
Read value: 876
Read value: 897
Read value: 923
Read value: 944
Read value: 957
Read value: 977
Read value: 995
Read value: 1000
</code></pre></div>
<p>As you can see, the receiving thread doesn’t receive every value. Each watcher
is guaranteed to be notified when changes occur and is guaranteed to be able to
retrieve the most recent value.</p>
<h3 id="async-support"><a href="#async-support">Async Support</a></h3>
<p>The <code>Watcher</code> type can be used in async code in multiple ways:</p>
<ul>
<li><code>Watcher::into_stream()</code>: Wraps the watcher in a type that implements
<code>futures::Stream</code>.</li>
<li><code>Watcher::wait_async().await</code>: Pauses execution of the current task until a
new value is available to be read. <code>Watcher::read()</code> can be used to retrieve
the current value after <code>wait_async()</code> has returned.</li>
</ul>
<p>Here is the same example as above, except this time using <code>Watcher::into_stream</code> with Tokio:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_util::StreamExt;
<span class="kw">use </span>watchable::{Watchable, Watcher};

<span class="attribute">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="comment">// Create a Watchable&lt;u32&gt; which holds a u32 and notifies watchers when the
    // contained value changes.
    </span><span class="kw">let </span>watchable = Watchable::default();
    <span class="comment">// Create a watcher that will efficiently be able to monitor and read the
    // contained value as it is updated.
    </span><span class="kw">let </span>watcher = watchable.watch();
    <span class="comment">// Spawn a background worker that will print out the values the watcher reads.
    </span><span class="kw">let </span>watching_task = tokio::task::spawn(watching_task(watcher));

    <span class="comment">// Store a sequence of values. Each time a new value is written, any waiting
    // watchers will be notified there is a new value available.
    </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">1_u32</span>..=<span class="number">1000 </span>{
        watchable.replace(i);
    }

    <span class="comment">// Once we&#39;re done sending values, dropping the Watchable will ensure
    // watchers are notified of the disconnection. Watchers are guaranteed to be
    // able to read the final value.
    </span>drop(watchable);

    <span class="comment">// Wait for the spawned task to exit.
    </span>watching_task.<span class="kw">await</span>.unwrap();
}

<span class="kw">async fn </span>watching_task(watcher: Watcher&lt;u32&gt;) {
    <span class="comment">// A Watcher can be converted into a Stream, which allows for asynchronous
    // iteration.
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream = watcher.into_stream();
    <span class="kw">while let </span><span class="prelude-val">Some</span>(value) = stream.next().<span class="kw">await </span>{
        <span class="comment">// The value we received will not necessarily be sequential, even though
        // the main thread is publishing a complete sequence.
        </span><span class="macro">println!</span>(<span class="string">&quot;Read value: {value}&quot;</span>);
    }
}</code></pre></div>
<p><code>watchable</code> is compatible with all async runtimes.</p>
<h3 id="open-source-licenses"><a href="#open-source-licenses">Open-source Licenses</a></h3>
<p>This project, like all projects from <a href="https://khonsulabs.com/">Khonsu Labs</a>, are
open-source. This repository is available under the <a href="./LICENSE-MIT">MIT License</a>
or the <a href="./LICENSE-APACHE">Apache License 2.0</a>.</p>
<p>To learn more about contributing, please see <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Disconnected.html" title="watchable::Disconnected struct">Disconnected</a></div><div class="item-right docblock-short">A watch operation failed because all <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> instances have been
dropped.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watchable.html" title="watchable::Watchable struct">Watchable</a></div><div class="item-right docblock-short">A watchable wrapper for a value.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableReadGuard.html" title="watchable::WatchableReadGuard struct">WatchableReadGuard</a></div><div class="item-right docblock-short">A read guard that allows reading the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>. No values can be stored within the source <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> while
this guard exists.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatchableWriteGuard.html" title="watchable::WatchableWriteGuard struct">WatchableWriteGuard</a></div><div class="item-right docblock-short">A write guard that allows updating the currently stored value in a
<a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Watcher.html" title="watchable::Watcher struct">Watcher</a></div><div class="item-right docblock-short">An observer of a <a href="struct.Watchable.html" title="Watchable"><code>Watchable</code></a> value.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WatcherStream.html" title="watchable::WatcherStream struct">WatcherStream</a></div><div class="item-right docblock-short">Asynchronous iterator for a <a href="struct.Watcher.html" title="Watcher"><code>Watcher</code></a>. Implements [<code>Stream</code>].</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TimeoutError.html" title="watchable::TimeoutError enum">TimeoutError</a></div><div class="item-right docblock-short">A watch operation with a timeout failed.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="watchable" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>